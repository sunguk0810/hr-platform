# HR SaaS Platform - Deploy Pipeline
# Deploy services to AWS ECS

name: Deploy to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: true
        default: 'all'
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
      run_migrations:
        description: 'Run database migrations'
        required: true
        type: boolean
        default: true

env:
  AWS_REGION: ap-northeast-2
  ALL_SERVICES: 'gateway-service,auth-service,tenant-service,organization-service,employee-service,attendance-service,approval-service,mdm-service'

jobs:
  # Job 1: Run Database Migrations
  migrate:
    name: Database Migration
    runs-on: ubuntu-latest
    if: ${{ inputs.run_migrations }}
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Get database credentials
        id: db-creds
        run: |
          DB_CREDS=$(aws secretsmanager get-secret-value \
            --secret-id "hr-platform/${{ inputs.environment }}/db-credentials" \
            --query 'SecretString' \
            --output text)
          echo "DB_HOST=$(echo $DB_CREDS | jq -r '.host')" >> $GITHUB_OUTPUT
          echo "DB_PORT=$(echo $DB_CREDS | jq -r '.port')" >> $GITHUB_OUTPUT
          echo "DB_USERNAME=$(echo $DB_CREDS | jq -r '.username')" >> $GITHUB_OUTPUT
          echo "::add-mask::$(echo $DB_CREDS | jq -r '.password')"
          echo "DB_PASSWORD=$(echo $DB_CREDS | jq -r '.password')" >> $GITHUB_OUTPUT

      - name: Run Flyway migrations
        run: |
          chmod +x gradlew

          # Migration order: tenant first, then others
          MIGRATION_ORDER="tenant-service auth-service mdm-service organization-service employee-service attendance-service approval-service"

          for SERVICE in $MIGRATION_ORDER; do
            echo "Running migrations for $SERVICE..."
            ./gradlew :services:${SERVICE}:flywayMigrate --no-daemon \
              -Dflyway.url="jdbc:postgresql://${{ steps.db-creds.outputs.DB_HOST }}:${{ steps.db-creds.outputs.DB_PORT }}/hr_saas" \
              -Dflyway.user="${{ steps.db-creds.outputs.DB_USERNAME }}" \
              -Dflyway.password="${{ steps.db-creds.outputs.DB_PASSWORD }}" \
              -Dflyway.outOfOrder=true || true
          done

  # Job 2: Deploy Services
  deploy:
    name: Deploy Services
    runs-on: ubuntu-latest
    needs: [migrate]
    if: always() && (needs.migrate.result == 'success' || needs.migrate.result == 'skipped')
    environment: ${{ inputs.environment }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine services to deploy
        id: services
        run: |
          if [ "${{ inputs.services }}" = "all" ]; then
            echo "SERVICES=${{ env.ALL_SERVICES }}" >> $GITHUB_OUTPUT
          else
            echo "SERVICES=${{ inputs.services }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy services to ECS
        run: |
          IFS=',' read -ra SERVICE_ARRAY <<< "${{ steps.services.outputs.SERVICES }}"

          for SERVICE in "${SERVICE_ARRAY[@]}"; do
            echo "Deploying $SERVICE..."

            # Update task definition with new image
            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "hr-platform-${{ inputs.environment }}-${SERVICE}" \
              --query 'taskDefinition' \
              --output json)

            # Get ECR registry
            ECR_REGISTRY=$(aws ecr describe-repositories \
              --repository-names "hr-platform/${SERVICE}" \
              --query 'repositories[0].repositoryUri' \
              --output text | cut -d'/' -f1)

            NEW_IMAGE="${ECR_REGISTRY}/hr-platform/${SERVICE}:${{ inputs.image_tag }}"

            # Update container image in task definition
            NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" \
              '.containerDefinitions[0].image = $IMAGE |
               del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

            # Register new task definition
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json "$NEW_TASK_DEF" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            echo "Registered new task definition: $NEW_TASK_ARN"

            # Update service
            aws ecs update-service \
              --cluster "hr-platform-${{ inputs.environment }}" \
              --service "$SERVICE" \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment

            echo "Updated service: $SERVICE"
          done

      - name: Wait for deployment stability
        run: |
          IFS=',' read -ra SERVICE_ARRAY <<< "${{ steps.services.outputs.SERVICES }}"

          for SERVICE in "${SERVICE_ARRAY[@]}"; do
            echo "Waiting for $SERVICE to stabilize..."

            aws ecs wait services-stable \
              --cluster "hr-platform-${{ inputs.environment }}" \
              --services "$SERVICE" \
              --region ${{ env.AWS_REGION }}

            echo "$SERVICE is stable!"
          done

      - name: Verify deployment
        run: |
          IFS=',' read -ra SERVICE_ARRAY <<< "${{ steps.services.outputs.SERVICES }}"

          echo "Deployment Summary:"
          echo "==================="

          for SERVICE in "${SERVICE_ARRAY[@]}"; do
            STATUS=$(aws ecs describe-services \
              --cluster "hr-platform-${{ inputs.environment }}" \
              --services "$SERVICE" \
              --query 'services[0].deployments[0].status' \
              --output text)

            RUNNING=$(aws ecs describe-services \
              --cluster "hr-platform-${{ inputs.environment }}" \
              --services "$SERVICE" \
              --query 'services[0].runningCount' \
              --output text)

            echo "$SERVICE: Status=$STATUS, Running=$RUNNING"
          done

  # Job 3: Post-deployment Health Check
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy]
    environment: ${{ inputs.environment }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ALB DNS
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names "hr-platform-${{ inputs.environment }}-alb" \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "ALB_DNS=$ALB_DNS" >> $GITHUB_OUTPUT

      - name: Health check
        run: |
          echo "Running health checks against ${{ steps.alb.outputs.ALB_DNS }}..."

          # Wait for services to be fully ready
          sleep 30

          # Check gateway health
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://${{ steps.alb.outputs.ALB_DNS }}/actuator/health" || echo "000")

          if [ "$HTTP_STATUS" = "200" ]; then
            echo "‚úÖ Gateway health check passed"
          else
            echo "‚ùå Gateway health check failed with status: $HTTP_STATUS"
            exit 1
          fi

      - name: Notify success
        if: success()
        run: |
          echo "üöÄ Deployment to ${{ inputs.environment }} completed successfully!"
          echo "ALB DNS: ${{ steps.alb.outputs.ALB_DNS }}"
