package com.hrsaas.attendance.service;

import com.hrsaas.attendance.domain.entity.LeaveAccrualRule;
import com.hrsaas.attendance.domain.entity.LeaveBalance;
import com.hrsaas.attendance.domain.entity.LeaveType;
import com.hrsaas.attendance.repository.LeaveAccrualRuleRepository;
import com.hrsaas.attendance.repository.LeaveBalanceRepository;
import com.hrsaas.common.tenant.TenantContext;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@DisplayName("LeaveCarryOverService Tests")
class LeaveCarryOverServiceTest {

    @Mock
    private LeaveBalanceRepository balanceRepository;

    @Mock
    private LeaveAccrualRuleRepository ruleRepository;

    @InjectMocks
    private LeaveCarryOverService leaveCarryOverService;

    @Captor
    private ArgumentCaptor<LeaveBalance> balanceCaptor;

    private static final UUID TENANT_ID = UUID.randomUUID();
    private static final UUID EMPLOYEE_ID = UUID.randomUUID();
    private static final int FROM_YEAR = 2025;
    private static final int TO_YEAR = 2026;

    @BeforeEach
    void setUp() {
        TenantContext.setCurrentTenant(TENANT_ID);
    }

    @AfterEach
    void tearDown() {
        TenantContext.clear();
    }

    @Test
    @DisplayName("processCarryOver: has remaining days, carries over with max limit")
    void processCarryOver_hasRemainingDays_carriesOverWithLimit() {
        // given
        // Previous year balance: total=15, used=5, pending=0, carriedOver=0 -> available=10
        LeaveBalance prevBalance = LeaveBalance.builder()
                .tenantId(TENANT_ID)
                .employeeId(EMPLOYEE_ID)
                .year(FROM_YEAR)
                .leaveType(LeaveType.ANNUAL)
                .totalDays(new BigDecimal("15"))
                .usedDays(new BigDecimal("5"))
                .pendingDays(BigDecimal.ZERO)
                .carriedOverDays(BigDecimal.ZERO)
                .build();

        // New year balance already exists (generated by annual accrual)
        LeaveBalance newBalance = LeaveBalance.builder()
                .tenantId(TENANT_ID)
                .employeeId(EMPLOYEE_ID)
                .year(TO_YEAR)
                .leaveType(LeaveType.ANNUAL)
                .totalDays(new BigDecimal("15"))
                .usedDays(BigDecimal.ZERO)
                .pendingDays(BigDecimal.ZERO)
                .carriedOverDays(BigDecimal.ZERO)
                .build();

        // Rule allows max 5 days carry over
        LeaveAccrualRule rule = LeaveAccrualRule.builder()
                .leaveTypeCode("ANNUAL")
                .maxCarryOverDays(new BigDecimal("5"))
                .build();

        when(balanceRepository.findByEmployeeIdAndYear(TENANT_ID, null, FROM_YEAR))
                .thenReturn(List.of(prevBalance));
        when(ruleRepository.findByTenantIdAndLeaveTypeCode(TENANT_ID, "ANNUAL"))
                .thenReturn(Optional.of(rule));
        when(balanceRepository.findByEmployeeIdAndYearAndType(TENANT_ID, EMPLOYEE_ID, TO_YEAR, LeaveType.ANNUAL))
                .thenReturn(Optional.of(newBalance));
        when(balanceRepository.save(any(LeaveBalance.class)))
                .thenAnswer(invocation -> invocation.getArgument(0));

        // when
        int count = leaveCarryOverService.processCarryOver(TENANT_ID, FROM_YEAR);

        // then
        assertThat(count).isEqualTo(1);
        verify(balanceRepository).save(balanceCaptor.capture());
        LeaveBalance saved = balanceCaptor.getValue();

        // Remaining=10, maxCarryOver=5 -> carries over min(10, 5) = 5
        assertThat(saved.getCarriedOverDays()).isEqualByComparingTo(new BigDecimal("5"));
        assertThat(saved.getYear()).isEqualTo(TO_YEAR);
        assertThat(saved.getEmployeeId()).isEqualTo(EMPLOYEE_ID);
    }

    @Test
    @DisplayName("processCarryOver: no remaining days, skips carry over")
    void processCarryOver_noRemaining_skips() {
        // given
        // Previous year balance: total=15, used=15, pending=0 -> available=0
        LeaveBalance prevBalance = LeaveBalance.builder()
                .tenantId(TENANT_ID)
                .employeeId(EMPLOYEE_ID)
                .year(FROM_YEAR)
                .leaveType(LeaveType.ANNUAL)
                .totalDays(new BigDecimal("15"))
                .usedDays(new BigDecimal("15"))
                .pendingDays(BigDecimal.ZERO)
                .carriedOverDays(BigDecimal.ZERO)
                .build();

        when(balanceRepository.findByEmployeeIdAndYear(TENANT_ID, null, FROM_YEAR))
                .thenReturn(List.of(prevBalance));

        // when
        int count = leaveCarryOverService.processCarryOver(TENANT_ID, FROM_YEAR);

        // then
        assertThat(count).isEqualTo(0);
        verify(balanceRepository, never()).save(any(LeaveBalance.class));
        // Should not look up rule since remaining <= 0
        verify(ruleRepository, never()).findByTenantIdAndLeaveTypeCode(any(), any());
    }

    @Test
    @DisplayName("processCarryOver: no rule found, defaults to zero carry over (skips)")
    void processCarryOver_noRule_usesDefaultZero() {
        // given
        // Previous year balance with remaining days
        LeaveBalance prevBalance = LeaveBalance.builder()
                .tenantId(TENANT_ID)
                .employeeId(EMPLOYEE_ID)
                .year(FROM_YEAR)
                .leaveType(LeaveType.ANNUAL)
                .totalDays(new BigDecimal("15"))
                .usedDays(new BigDecimal("5"))
                .pendingDays(BigDecimal.ZERO)
                .carriedOverDays(BigDecimal.ZERO)
                .build();

        when(balanceRepository.findByEmployeeIdAndYear(TENANT_ID, null, FROM_YEAR))
                .thenReturn(List.of(prevBalance));
        // No rule found
        when(ruleRepository.findByTenantIdAndLeaveTypeCode(TENANT_ID, "ANNUAL"))
                .thenReturn(Optional.empty());

        // when
        int count = leaveCarryOverService.processCarryOver(TENANT_ID, FROM_YEAR);

        // then
        // maxCarryOver defaults to ZERO when no rule -> skips (ZERO <= 0)
        assertThat(count).isEqualTo(0);
        verify(balanceRepository, never()).save(any(LeaveBalance.class));
    }
}
